

## 美团

### [美团2021校招笔试-编程题(通用编程试题,第10场)](https://www.nowcoder.com/test/28665343/summary)

#### 淘汰分数

某比赛已经进入了淘汰赛阶段,已知共有n名选手参与了此阶段比赛，他们的得分分别是a_1,a_2….a_n,小美作为比赛的裁判希望设定一个分数线m，使得所有分数大于m的选手晋级，其他人淘汰。

但是为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在[x,y]之间。

显然这个m有可能是不存在的，也有可能存在多个m，如果不存在，请你输出-1，如果存在多个，请你输出符合条件的最低的分数线。

```java
    public void t1() throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String[] inputOne = reader.readLine().split(" ");

        int n = Integer.parseInt(inputOne[0]);
        int x = Integer.parseInt(inputOne[1]);
        int y = Integer.parseInt(inputOne[2]);

        String[] inputTow = reader.readLine().split(" ");

        int[] scores = new int[n];
        for (int i = 0; i < n; i++) {
            scores[i] = Integer.parseInt(inputTow[i]);
        }

        Arrays.sort(scores);


        int m = -1;

        for (int i = 0; i < n; i++) {
            if (i + 1 >= x && i + 1 <= y && n - i - 1 >= x && n - i - 1 <= y) {
                m = scores[i];
                break;
            }
        }

        System.out.println(m);
    }

```

#### 正则序列
我们称一个长度为n的序列为正则序列，当且仅当该序列是一个由1~n组成的排列，即该序列由n个正整数组成，取值在[1,n]范围，且不存在重复的数，同时正则序列不要求排序

有一天小团得到了一个长度为n的任意序列s，他需要在有限次操作内，将这个序列变成一个正则序列，每次操作他可以任选序列中的一个数字，并将该数字加一或者减一。

请问他最少用多少次操作可以把这个序列变成正则序列？

```java
    public void t2() throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String inputOne = reader.readLine();

        int n = Integer.parseInt(inputOne);

        String[] inputTwo = reader.readLine().split(" ");
        int[] ints = new int[n];
        for (int i = 0; i < n; i++) {
            ints[i] = Integer.parseInt(inputTwo[i]);
        }

        Arrays.sort(ints);
        
        int res = 0;

        for (int i = 1; i <= n; i++) {

            res += Math.abs(i - ints[i - 1]);

        }

        System.out.println(res);

    }

```

#### 公司食堂
小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；

当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；

无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌。

```java
    
    // 无法 AC

    public static PriorityQueue<Integer> zeroQueue = new PriorityQueue<>(((o1, o2) -> o1 - o2));
    public static PriorityQueue<Integer> oneQueue = new PriorityQueue<>(((o1, o2) -> o1 - o2));

    public static void main(String[] args) throws Exception {


        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int T = Integer.parseInt(reader.readLine());

        for (int i = 0; i < T; i++) {

            int N = Integer.parseInt(reader.readLine());

            String one = reader.readLine();

            int M = Integer.parseInt(reader.readLine());

            String two = reader.readLine();

            int[] m = m(one, two);

            for (int k : m) {
                System.out.println(k);
            }


        }


    }

    public static int[] m(String one, String two) {

        int[] res = new int[two.length()];

        for (int i = 0; i < one.length(); i++) {
            int c = one.charAt(i) - '0';
            if (c == 0) zeroQueue.add(i + 1);
            else if (c == 1) oneQueue.add(i + 1);
        }

        for (int i = 0; i < two.length(); i++) {
            char c = two.charAt(i);

            if (c == 'M') {
                if (oneQueue.isEmpty()) {
                    res[i] = zeroQueue.peek();
                    oneQueue.add(zeroQueue.poll());
                } else res[i] = oneQueue.poll();
            } else if (c == 'F') {
                if (zeroQueue.isEmpty()) {
                    res[i] = oneQueue.poll();
                } else {
                    res[i] = zeroQueue.peek();
                    oneQueue.add(zeroQueue.poll());
                }

            }

        }

        zeroQueue.clear();
        oneQueue.clear();

        return res;


    }

```


#### 最优二叉树II

小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。
小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。
之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。





### [美团2021校招笔试-编程题(通用编程试题,第9场)](https://www.nowcoder.com/test/28665338/summary)

#### 糕点
    小团的蛋糕铺长期霸占着美团APP中“蛋糕奶茶”栏目的首位，因此总会吸引各路食客前来探店。
    
    小团一天最多可以烤n个蛋糕，每个蛋糕有一个正整数的重量。
    
    早上，糕点铺已经做好了m个蛋糕。
    
    现在，有一个顾客要来买两个蛋糕，他希望买这一天糕点铺烤好的最重的和最轻的蛋糕，并且希望这两个蛋糕的重量恰好为a和b。剩余的n-m个蛋糕可以现烤，请问小团能否满足他的要求？
    
    数据范围：，
    进阶：时间复杂度,空间复杂度
    
    输入描述:
    输入包含多组数据，每组数据两行。
    
    每组数据的第一行包含4个整数，n,m,a,b，空格隔开。这里不保证a和b的大小关系。
    
    接下来一行m个数，空格隔开，代表烤好的蛋糕重量
    
    
    输出描述:
    对于每一组数据，如果可以办到顾客的要求，输出YES，否则输出NO
    
    
    输入例子1:
    4 2 2 4
    3 3
    4 2 2 4
    1 1
    4 2 2 4
    5 5
    4 2 4 2
    2 4
    2 2 2 4
    3 3
    3 2 2 4
    3 3
    3 2 2 4
    3 3
    
    输出例子1:
    YES
    NO
    NO
    YES
    NO
    NO
    NO

```java
模拟一下，在保证a<b的情况下，有如下几种情况：
        (1) 已经烤好的蛋糕中，重量最小的比a轻，或者重量最大的比b重，肯定无法满足要求。
        (2) 已经烤好的蛋糕重量都在区间[a,b]中
        i) 已经有a和b两个重量，可以满足要求。
        ii) 已经有a或b之中的一个重量，并且还能现烤的蛋糕数不少于1，那就肯定还能够烤一个需要的重量；否则不能满足要求。
        iii) 需要的两个重量都没有，并且能还能现烤的蛋糕数不少于2，那就肯定可以把需要的两个重量都烤了；否则不能满足要求。

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        String[] params;
        while((line = br.readLine()) != null) {
            params = line.trim().split(" ");
            int n = Integer.parseInt(params[0]);
            int m = Integer.parseInt(params[1]);
            int a = Integer.parseInt(params[2]);
            int b = Integer.parseInt(params[3]);
            params = br.readLine().trim().split(" ");
            int[] weight = new int[m];
            HashSet<Integer> set = new HashSet<>();      // 保存现有蛋糕的重量
            for(int i = 0; i < m; i++) {
                weight[i] = Integer.parseInt(params[i]);
                set.add(weight[i]);
            }
            Arrays.sort(weight);
            // 保证a<b
            if(a > b){
                int temp = a;
                a = b;
                b = temp;
            }
            if(weight[0] < a || weight[m - 1] > b){
                // 现有蛋糕中，重量最小的小于a，最大的大于b，肯定完成不了需求
                System.out.println("NO");
            }else{
                if(set.contains(a) && set.contains(b))   // 如果现有蛋糕中已经包含了a和b，就没问题
                    System.out.println("YES");
                else{
                    if(set.contains(a) || set.contains(b)){
                        // 如果只包含a或b，检查一下n-m是否大于等于1，即还有一个重量需要现烤
                        System.out.println(n - m >= 1 && weight[m - 1] <= b? "YES": "NO");
                    }else{
                        // 否则需要检查n-m是否大于等于2，即两个重量都需要现烤
                        System.out.println(n - m >= 2? "YES": "NO");
                    }
                }
            }
        }
    }
}
```

### 晋级人数
    小团是某综艺节目的策划，他为某个游戏环节设计了一种晋级规则，已知在这个游戏环节中每个人最后都会得到一个分数score_i，显而易见的是，游戏很有可能出现同分的情况，小团计划该环节晋级人数为x人，则将所有人的分数从高到低排序，所有分数大于等于第x个人的分数且得分不为0的人都可以晋级。
    
    请你求出本环节的实际晋级人数。显然这个数字可能是0，如果所有人的得分都是0，则没有人满足晋级条件。

    输入描述:
    输入第一行包含两个正整数n和x，分别表示参加本环节的人数，和小团指定的x。
    
    输入第二行包含n个整数，每个整数表示一位选手的得分。
    
    
    输出描述:
    输出仅包含一个整数，表示实际晋级人数。
    
    输入例子1:
    5 4
    0 0 2 3 4
    
    输出例子1:
    3
```java
    /*
    这个“小团计划晋级x人”很误导我，刚开始还以为晋级人数只会<=x。但实际上如果分数排名第x的人的分数不为0且存在并列的情况，
    会将并列的人全部晋级，从而使得晋级人数超过x。我们先对分数进行排序（可以升序也可以降序），然后分以下几种情况进行讨论：
    (1) 如果最大值为0，那肯定所有得分均为0，没有人晋级。
    (2) 如果最大值不为0，先计算以下分数第x大的人得了多少分，作为baseline：
      i) 如果baseline为0，就要找到第一个分数不为0的人，分数大于等于他的都能晋级。
      ii) 如果baseline为0，就检查还有多少个并列，把这些人也一同晋级。
     */

    public static void main(String[] args) throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));


        String[] paramsOne = reader.readLine().split(" ");
        int n = Integer.parseInt(paramsOne[0]);
        int x = Integer.parseInt(paramsOne[1]);


        Integer[] scores = new Integer[n];
        String[] paramsTwo = reader.readLine().split(" ");

        for (int i = 0; i < paramsTwo.length; i++) {
            scores[i] = Integer.parseInt(paramsTwo[i]);
        }

        Arrays.sort(scores, ((o1, o2) -> o2 - o1));

        int count = x;

        if (scores[0] == 0) {
            count = 0;
        } else {
            int val = scores[x - 1];
            if (val > 0) {
                //找相同的
                int index = x;
                while (index < n && scores[index] == val) {
                    count++;
                    index++;
                }
            } else {
                int index = x - 1;
                while (index >= 0 && scores[index] == val) {
                    count--;
                    index--;
                }
            }


            System.out.println(count);

        }


    }
```

### 回转寿司
    小美请小团吃回转寿司。转盘上有N盘寿司围成一圈，第1盘与第2盘相邻，第2盘与第3盘相邻，…，第N-1盘与第N盘相邻，第N盘与第1盘相邻。小团认为第i盘寿司的美味值为A[i]（可能是负值，如果小团讨厌这盘寿司）。现在，小团要在转盘上选出连续的若干盘寿司，使得这些寿司的美味值之和最大（允许不选任何寿司，此时美味值总和为0）。
    
    
    输入描述:
    第一行输入一个整数T（1<=T<=10），表示数据组数。
    
    每组数据占两行，第一行输入一个整数N（1<=N<=10^5）；
    
    第二行输入N个由空格隔开的整数，表示A[1]到A[N]（-10^4<=A[i]<=10^4）。
    
    
    输出描述:
    每组数据输出占一行，输出一个整数，表示连续若干盘寿司的美味值之和的最大值。
    
    输入例子1:
    1
    4
    3 -2 4 -1
    
    输出例子1:
    6
    
    例子说明1:
    美味值之和最大连续若干盘寿司为第3盘、第4盘和第1盘。 

```java

    /*
    题目要求环形数组的连续子数组的最大和，我们先不要去管数组是环形的情况，利用动态规划求解连续子数组的最大和以及最小和。
    (1) 不考虑环形得到的最大值：题中允许寿司首尾相连的环形数组情况，因此常规求得的连续子数组的最大和就是我们排除这种情况之外的所有情况中的最大和。
    (2) 只考虑环形得到的最大值：而对于首尾相连的情况，我们可以这样考虑，如果常规求得的连续子数组的和达到了最小，那么总和减去这个最小值就等于首尾相连情况的最大值了。
    因此最大的美味值就是(1)和(2)两种情况中大的那个。
    ---------------------------------------------------------------------------------------------------------------------------
    接下来说一下动态规划如何求解连续子数组的最大和：
    状态定义：dp[i]表示以 i 结尾的连续子数组的最大和
    状态转移方程：dp[i] = max(array[i], dp[i-1]+array[i])
    状态转移方程的意思是：如果选择了当前元素i，而dp[i-1]为负数，表明之前的和做的是负贡献，会使得整体的和变小，因此这时候选择从array[i]重新开始计算和。
    考虑到我们并不需要求得dp数组中所有的值，而是只需要最大值，所以还可以对空间复杂度进行优化。每次计算得到其中一个dp[i]时，就更新当前的最大值，
    而dp[i]之前的取值(dp[0],dp[1],...,dp[i-1])已经用过，所以不需要再保留了，仅用一个变量代替dp数组即可。
    求解连续子数组的最小和只要将以上的max改成min就可以了......
     */
    
    public static void main(String[] args) throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int T = Integer.parseInt(reader.readLine());

        while (T-- > 0) {

            int N = Integer.parseInt(reader.readLine());

            int[] A = new int[N];

            String[] paramsOne = reader.readLine().split(" ");
            int sum = 0;
            for (int i = 0; i < paramsOne.length; i++) {
                A[i] = Integer.parseInt(paramsOne[i]);
                sum += A[i];
            }

            int max = A[0], min = A[0];
            int dMax = A[0], dMin = A[0];

            for (int i = 1; i < N; i++) {

                dMax = Math.max(dMax + A[i], A[i]);
                max = Math.max(dMax, max);

                dMin = Math.min(dMin + A[i], A[i]);
                min = Math.min(min, dMin);

            }

            System.out.println(Math.max(sum - min, max));

        }

    }
```

### 神秘的苹果树
    小团找到一颗有n个节点的苹果树，以1号节点为根，且每个节点都有一个苹果，苹果都有一个颜色，但是这棵树被施加了咒术，这使得小团只能从某一个节点的子树中选取某一种颜色的拿。
    小团想要拿到数量最多的那种颜色的所有苹果，请帮帮她。每次她会指定一个节点t，如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？
    如果有多种颜色都可以拿同样多的苹果，输出颜色编号最小的那个对应的编号。
    
    节点x的子树定义为所有将x当作祖先的节点，x也视为x的子树的一部分。
    
    
    输入描述:
    第一行一个正整数n表示这颗树上节点的个数。
    
    接下来n-1行，每行两个正整数xi,yi,表示树上第i条边连接的两个节点。
    
    接下来一行n个正整数ci，分别表示从1~n号节点上的苹果的颜色。
    
    接下来一行一个正整数q,表示接下来有q次独立的询问。
    
    接下来q行，每行一个正整数t表示询问：如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？如果有多种颜色都可以拿同样多的苹果，
    输出颜色编号最小的那个对应的编号。
    
    对于100%的数据n≤5000, 1≤xi,yi,t≤n, ci≤1000000000,q≤1000
    
    输出描述:
    输出q行，每行一个整数，表示答案。
    
    输入例子1:
    7
    1 2
    1 3
    2 4
    2 5
    3 6
    3 7
    1 1 2 1 2 2 3
    7
    1
    2
    3
    4
    5
    6
    7
    
    输出例子1:
    1
    1
    2
    1
    2
    2
    3
```java

```


