

## 美团

### [美团2021校招笔试-编程题(通用编程试题,第10场)](https://www.nowcoder.com/test/28665343/summary)

#### 淘汰分数

某比赛已经进入了淘汰赛阶段,已知共有n名选手参与了此阶段比赛，他们的得分分别是a_1,a_2….a_n,小美作为比赛的裁判希望设定一个分数线m，使得所有分数大于m的选手晋级，其他人淘汰。

但是为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在[x,y]之间。

显然这个m有可能是不存在的，也有可能存在多个m，如果不存在，请你输出-1，如果存在多个，请你输出符合条件的最低的分数线。

```java
    public void t1() throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String[] inputOne = reader.readLine().split(" ");

        int n = Integer.parseInt(inputOne[0]);
        int x = Integer.parseInt(inputOne[1]);
        int y = Integer.parseInt(inputOne[2]);

        String[] inputTow = reader.readLine().split(" ");

        int[] scores = new int[n];
        for (int i = 0; i < n; i++) {
            scores[i] = Integer.parseInt(inputTow[i]);
        }

        Arrays.sort(scores);


        int m = -1;

        for (int i = 0; i < n; i++) {
            if (i + 1 >= x && i + 1 <= y && n - i - 1 >= x && n - i - 1 <= y) {
                m = scores[i];
                break;
            }
        }

        System.out.println(m);
    }

```

#### 正则序列
我们称一个长度为n的序列为正则序列，当且仅当该序列是一个由1~n组成的排列，即该序列由n个正整数组成，取值在[1,n]范围，且不存在重复的数，同时正则序列不要求排序

有一天小团得到了一个长度为n的任意序列s，他需要在有限次操作内，将这个序列变成一个正则序列，每次操作他可以任选序列中的一个数字，并将该数字加一或者减一。

请问他最少用多少次操作可以把这个序列变成正则序列？

```java
    public void t2() throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String inputOne = reader.readLine();

        int n = Integer.parseInt(inputOne);

        String[] inputTwo = reader.readLine().split(" ");
        int[] ints = new int[n];
        for (int i = 0; i < n; i++) {
            ints[i] = Integer.parseInt(inputTwo[i]);
        }

        Arrays.sort(ints);
        
        int res = 0;

        for (int i = 1; i <= n; i++) {

            res += Math.abs(i - ints[i - 1]);

        }

        System.out.println(res);

    }

```

#### 公司食堂
小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；

当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；

无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌。

```java
    
    // 无法 AC

    public static PriorityQueue<Integer> zeroQueue = new PriorityQueue<>(((o1, o2) -> o1 - o2));
    public static PriorityQueue<Integer> oneQueue = new PriorityQueue<>(((o1, o2) -> o1 - o2));

    public static void main(String[] args) throws Exception {


        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int T = Integer.parseInt(reader.readLine());

        for (int i = 0; i < T; i++) {

            int N = Integer.parseInt(reader.readLine());

            String one = reader.readLine();

            int M = Integer.parseInt(reader.readLine());

            String two = reader.readLine();

            int[] m = m(one, two);

            for (int k : m) {
                System.out.println(k);
            }


        }


    }

    public static int[] m(String one, String two) {

        int[] res = new int[two.length()];

        for (int i = 0; i < one.length(); i++) {
            int c = one.charAt(i) - '0';
            if (c == 0) zeroQueue.add(i + 1);
            else if (c == 1) oneQueue.add(i + 1);
        }

        for (int i = 0; i < two.length(); i++) {
            char c = two.charAt(i);

            if (c == 'M') {
                if (oneQueue.isEmpty()) {
                    res[i] = zeroQueue.peek();
                    oneQueue.add(zeroQueue.poll());
                } else res[i] = oneQueue.poll();
            } else if (c == 'F') {
                if (zeroQueue.isEmpty()) {
                    res[i] = oneQueue.poll();
                } else {
                    res[i] = zeroQueue.peek();
                    oneQueue.add(zeroQueue.poll());
                }

            }

        }

        zeroQueue.clear();
        oneQueue.clear();

        return res;


    }

```


#### 最优二叉树II

小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。
小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。
之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。

